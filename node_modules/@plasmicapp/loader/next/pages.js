"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateNextPages = void 0;
const fs_1 = require("fs");
const upath_1 = __importDefault(require("upath"));
const logger = __importStar(require("../shared/logger"));
const templates_1 = __importDefault(require("../templates"));
async function isUserManagedFile(path) {
    try {
        const content = await fs_1.promises.readFile(path);
        return !content
            .toString()
            .startsWith("/** This file is auto-generated by Plasmic");
    }
    catch (error) {
        if (error.code === "ENOENT") {
            return false;
        }
        throw error;
    }
}
let didWarnConflictingRoot = false;
let didWarnConflictingCatchAll = false;
async function syncIndexPage(page, pageDir, fileExtension) {
    const fileName = `index.${fileExtension}`;
    const filePath = upath_1.default.join(pageDir, fileName);
    const managedByUser = await isUserManagedFile(filePath);
    // Do not modify the file if it is managed by the user.
    if (managedByUser) {
        if (page && !didWarnConflictingRoot) {
            logger.warn(`Top-level ${fileName} detected.\nPlasmic uses a catch-all file to register Plasmic pages. Because of this conflict, Plasmic wont register this page.`);
            didWarnConflictingRoot = true;
        }
        return;
    }
    if (!page) {
        try {
            await fs_1.promises.unlink(filePath);
        }
        catch (error) {
            if (error.code !== "ENOENT") {
                throw error;
            }
        }
        return;
    }
    await fs_1.promises.writeFile(filePath, templates_1.default.PlasmicPage({
        name: page.name,
        projectId: page.projectId,
    }));
}
async function syncCatchAllPage(pages, pageDir, fileExtension) {
    if (!pages.length) {
        return;
    }
    const topLevelPages = await fs_1.promises.readdir(pageDir);
    const catchAllFile = topLevelPages.find((page) => page.startsWith("["));
    // No catch-all. We'll create our own as a default.
    if (!catchAllFile) {
        const fileName = `[...plasmicLoaderPage].${fileExtension}`;
        const filePath = upath_1.default.join(pageDir, fileName);
        await fs_1.promises.writeFile(filePath, templates_1.default.NextPage());
        return;
    }
    // Emit a warning if the catch all does not make use of our plasmic pages.
    const catchAllContent = await fs_1.promises
        .readFile(upath_1.default.join(pageDir, catchAllFile))
        .then((content) => content.toString());
    const includesPagesFunction = catchAllContent.includes("getPageUrls") ||
        catchAllContent.includes("getUnregisteredPageUrls");
    const includesLoaderImport = catchAllContent.includes("@plasmicapp/loader");
    if (!includesPagesFunction || !includesLoaderImport) {
        if (!didWarnConflictingCatchAll) {
            logger.warn(`To use PlasmicPages, please add it to your top-level catch-all "${catchAllFile}".` +
                "\n\nHere's an example on how to do it in NextJS: https://github.com/plasmicapp/nextjs-starter/blob/master/pages/[...plasmicLoaderPage].js" +
                "\n\nAlternatively, you can remove this file.");
        }
        didWarnConflictingCatchAll = true;
        return;
    }
}
async function generateNextPages(pages, dir, config) {
    const extension = config.code.lang === "js" ? "js" : "tsx";
    const indexPage = pages.find((page) => page.url === "/");
    const otherPages = pages.filter((page) => page.url !== "/");
    await Promise.all([
        syncIndexPage(indexPage, dir, extension),
        syncCatchAllPage(otherPages, dir, extension),
    ]);
}
exports.generateNextPages = generateNextPages;
