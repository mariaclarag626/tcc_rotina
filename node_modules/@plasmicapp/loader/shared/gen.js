"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.genStaticNodeModuleExports = exports.generateAll = exports.getConfigData = void 0;
const fs_1 = require("fs");
const upath_1 = __importDefault(require("upath"));
const templates_1 = __importDefault(require("../templates"));
function isPageData(data) {
    return data.type === "page";
}
function pageExists(pageUrl, pageDir, extension) {
    const pagePath = upath_1.default.join(pageDir, ...(pageUrl + extension).split("/"));
    return fs_1.promises
        .access(pagePath)
        .then(() => true)
        .catch((error) => {
        if (error.code === "ENOENT") {
            return false;
        }
        throw error;
    });
}
function stripExtension(filename, removeComposedPath = false) {
    const ext = removeComposedPath
        ? filename.substring(filename.indexOf("."))
        : upath_1.default.extname(filename);
    if (!ext || filename === ext) {
        return filename;
    }
    return filename.substring(0, filename.lastIndexOf(ext));
}
function writeFile(filePath, content) {
    return fs_1.promises
        .mkdir(upath_1.default.dirname(filePath), { recursive: true })
        .then(() => fs_1.promises.writeFile(filePath, content));
}
async function getConfigData(opts) {
    var _a;
    const configPath = upath_1.default.join(opts.dir, "plasmic.json");
    const configData = await fs_1.promises.readFile(configPath);
    const config = JSON.parse(configData.toString());
    const extension = config.code.lang === "js" ? ".js" : ".tsx";
    const componentData = [];
    const componentDataKeyedByName = {};
    const addToComponentData = (data) => {
        if (!componentDataKeyedByName[data.name]) {
            componentDataKeyedByName[data.name] = [];
        }
        componentData.push(data);
        componentDataKeyedByName[data.name].push(data);
    };
    for (const project of config.projects) {
        for (const component of project.components) {
            const blackboxPath = upath_1.default.join(opts.dir, config.srcDir, component.renderModuleFilePath);
            const skeletonPath = upath_1.default.join(opts.dir, config.srcDir, component.importSpec.modulePath);
            const componentObj = {
                name: component.name,
                projectId: project.projectId,
                path: component.plumeType ? skeletonPath : blackboxPath,
                type: component.componentType,
            };
            if (isPageData(componentObj)) {
                componentObj.url = getPageUrl(component.importSpec.modulePath);
                componentObj.isRegistered = await pageExists(componentObj.url, opts.pageDir, extension);
                componentObj.skeletonPath = skeletonPath;
            }
            // isRegistered
            addToComponentData(componentObj);
        }
        project.icons.forEach((icon) => addToComponentData({
            name: icon.name,
            projectId: project.projectId,
            path: upath_1.default.join(opts.dir, config.srcDir, icon.moduleFilePath),
            type: icon.componentType,
        }));
    }
    const providerData = [];
    const providersKeyedByName = {};
    for (const provider of ((_a = config.globalVariants) === null || _a === void 0 ? void 0 : _a.variantGroups) || []) {
        const data = {
            name: provider.name,
            projectId: provider.projectId,
            path: upath_1.default.join(opts.dir, config.srcDir, provider.contextFilePath),
            providerName: provider.name === "Screen" ? "ScreenVariantProvider" : "",
            type: "provider",
        };
        if (!providersKeyedByName[data.name]) {
            providersKeyedByName[data.name] = [];
        }
        providerData.push(data);
        providersKeyedByName[data.name].push(data);
    }
    return {
        plasmicDir: opts.dir,
        componentData,
        componentDataKeyedByName,
        providerData,
        providersKeyedByName,
    };
}
exports.getConfigData = getConfigData;
async function generateAll(opts) {
    const configData = await getConfigData(opts);
    await Promise.all([
        generatePlasmicLoader(configData),
        generatePageComponents(configData),
        generatePlasmicTypes(configData),
    ]);
}
exports.generateAll = generateAll;
/**
 * This allows folks to import from "@plasmicapp/loader". Dynamic parts
 * should be kept outside, as node_modules may be cached (e.g by webpack).
 */
async function genStaticNodeModuleExports(plasmicDir) {
    // This content works for both the main file and the typescript types.
    const fileContent = templates_1.default.LoaderExport({
        path: `${plasmicDir}/PlasmicLoader.jsx`,
    });
    return Promise.all([
        writeFile(upath_1.default.join(__dirname, "../", "PlasmicLoader.jsx"), fileContent),
        writeFile(upath_1.default.join(__dirname, "../", "PlasmicLoader.d.ts"), fileContent),
        fs_1.promises.copyFile(upath_1.default.join(__dirname, "../", "PlasmicLoaderTypes.d.ts"), upath_1.default.join(plasmicDir, "PlasmicLoader.d.ts")),
    ]);
}
exports.genStaticNodeModuleExports = genStaticNodeModuleExports;
function generatePlasmicTypes(config) {
    const singleComponents = Object.values(config.componentDataKeyedByName)
        .filter((components) => components.length === 1)
        .flat()
        .map((component) => ({
        ...component,
        path: stripExtension(component.path),
    }));
    const components = config.componentData.map((component) => ({
        ...component,
        path: stripExtension(component.path),
    }));
    const providersKeyedByProjectId = {};
    config.providerData.forEach((provider) => {
        if (!providersKeyedByProjectId[provider.projectId]) {
            providersKeyedByProjectId[provider.projectId] = [];
        }
        providersKeyedByProjectId[provider.projectId].push(provider);
    });
    const providersWithProjects = Object.entries(providersKeyedByProjectId).map(([projectId, providers]) => ({
        projectId,
        providers: providers.map((provider) => ({
            ...provider,
            path: stripExtension(provider.path),
        })),
    }));
    const singleProviders = Object.values(config.providersKeyedByName)
        .filter((providers) => providers.length === 1)
        .flat()
        .map((provider) => ({
        ...provider,
        path: stripExtension(provider.path),
    }));
    return writeFile(upath_1.default.join(config.plasmicDir, "loaderTypes.d.ts"), templates_1.default.LoaderTypes({
        singleComponents,
        components,
        providersWithProjects,
        singleProviders,
    }));
}
async function generatePageComponents(config) {
    // TODO: doing it sequentially because we may have the same page in multiple
    // projects. This results in writing to the same file, which may creates wrong file content.
    // This way, the last page will be synced.
    for (const data of config.componentData.filter(isPageData)) {
        await writeFile(data.skeletonPath, templates_1.default.PlasmicPage({
            name: data.name,
            projectId: data.projectId,
        }));
    }
}
function getPageUrl(path) {
    // Convert a page path (like pages/my-page.tsx or ../pages/index.jsx) into their
    // corresponding path (/my-page).
    let [_, url] = path.split(/pages(.*)\..*$/);
    // Remove the ending "/index" path, which is required for file routing but not for URLs.
    // Examples:
    // /index -> /
    // /index/index -> /index
    if (url.endsWith("index")) {
        url = url.slice(0, -6);
    }
    return url === "" ? "/" : url;
}
function generatePlasmicLoader(config) {
    const entrypointPath = upath_1.default.join(config.plasmicDir, "PlasmicLoader.jsx");
    return writeFile(entrypointPath, templates_1.default.PlasmicLoader({
        componentData: config.componentData,
        pagesByUrl: config.componentData.filter(isPageData),
        unregisteredPagesByUrl: config.componentData
            .filter(isPageData)
            .filter((page) => !page.isRegistered),
        componentsWithOneProject: Object.values(config.componentDataKeyedByName)
            .filter((components) => components.length === 1)
            .flat(),
        componentMap: Object.entries(config.componentDataKeyedByName).map(([name, projects]) => ({ name, projects })),
        providerData: config.providerData,
        providersWithOneProject: Object.values(config.providersKeyedByName)
            .filter((providers) => providers.length === 1)
            .flat(),
        providerMap: Object.entries(config.providersKeyedByName).map(([name, projects]) => ({ name, projects })),
        plasmicDir: config.plasmicDir,
    }));
}
