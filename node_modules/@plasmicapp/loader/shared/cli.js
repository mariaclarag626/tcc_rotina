"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.syncProject = exports.getPagesFromConfig = exports.fixImports = exports.saveConfig = exports.readConfig = exports.tryInitializePlasmicDir = exports.ensureRequiredLoaderVersion = exports.getCurrentUser = exports.getEnv = void 0;
const execa_1 = __importDefault(require("execa"));
const fs_1 = require("fs");
const upath_1 = __importDefault(require("upath"));
const api = __importStar(require("./api"));
const config = __importStar(require("./config"));
const logger = __importStar(require("./logger"));
const metadata_1 = require("./metadata");
const semver = __importStar(require("./semver"));
const sentry_1 = require("./sentry");
const utils_1 = require("./utils");
Object.assign(process.env, {
    QUIET: "1",
    PLASMIC_LOADER: "1",
    npm_config_yes: "1",
});
function getEnv() {
    return {
        QUIET: "1",
        ...process.env,
        PLASMIC_LOADER: "1",
        npm_config_yes: "1",
        NODE_OPTIONS: process.env.LOADER_CLI_NODE_OPTIONS,
    };
}
exports.getEnv = getEnv;
async function runCommand(command, opts = {}) {
    if (!opts.dir)
        opts.dir = process.cwd();
    if (!opts.hideOutput)
        opts.hideOutput = false;
    const [file, ...args] = command.split(" ");
    return execa_1.default(file, args, {
        cwd: opts.dir,
        env: getEnv(),
        stdio: opts.hideOutput ? "pipe" : "inherit",
    });
}
function objToExecArgs(obj) {
    return Object.entries(obj)
        .map(([param, value]) => `--${param}=${Array.isArray(value) ? value.join(",") : value}`)
        .join(" ");
}
function getCurrentUser(plasmicDir) {
    const userCli = require(upath_1.default.join(plasmicDir, "node_modules", "@plasmicapp", "cli", "dist", "lib.js"));
    return userCli
        .auth({ email: true, baseDir: plasmicDir })
        .catch((error) => {
        var _a;
        const hasInvalidCredentials = (_a = error.message) === null || _a === void 0 ? void 0 : _a.includes("authentication credentials");
        if (!hasInvalidCredentials) {
            sentry_1.captureException(error);
        }
        return "";
    });
}
exports.getCurrentUser = getCurrentUser;
async function ensureRequiredLoaderVersion() {
    const requiredVersions = await api.getRequiredPackages().catch((error) => {
        let message = `Unable to verify loader version. Error: ${error.message}.`;
        if (error.response) {
            message += `\n\n${error.response.data}`;
        }
        throw new Error(message);
    });
    const version = config.packageJson.version;
    if (semver.gt(requiredVersions["@plasmicapp/loader"], version)) {
        logger.crash("A newer version of @plasmicapp/loader is required. Please upgrade your current version and try again.");
    }
}
exports.ensureRequiredLoaderVersion = ensureRequiredLoaderVersion;
async function installPackages(plasmicDir) {
    await fs_1.promises.writeFile(upath_1.default.join(plasmicDir, "package.json"), `{
  "name":"plasmic-loader",
  "version":"0.0.1",
  "dependencies": {
    "@plasmicapp/react-web": "*",
    "@plasmicapp/cli": "*"
  }
}`);
    if (process.env.DO_YALC_ADD_CLI) {
        await runCommand("yalc add @plasmicapp/cli", {
            dir: plasmicDir,
            hideOutput: true,
        });
    }
    if (!process.env.NO_INSTALL) {
        await runCommand("npm update --no-package-lock --legacy-peer-deps", {
            dir: plasmicDir,
        });
    }
}
async function tryInitializePlasmicDir(plasmicDir, initArgs = {}) {
    await fs_1.promises.mkdir(plasmicDir, { recursive: true });
    await installPackages(plasmicDir);
    const currentUser = await getCurrentUser(plasmicDir);
    if (currentUser) {
        sentry_1.setUser(currentUser);
    }
    const configPath = upath_1.default.join(plasmicDir, "plasmic.json");
    const userCli = require(upath_1.default.join(plasmicDir, "node_modules", "@plasmicapp", "cli", "dist", "lib.js"));
    try {
        await fs_1.promises.access(configPath);
    }
    catch (error) {
        if (error.code !== "ENOENT") {
            throw error;
        }
        await userCli.initPlasmic({
            ...Object.fromEntries(Object.keys(initArgs).map((key) => [utils_1.toCamelCase(key), initArgs[key]])),
            enableSkipAuth: true,
            yes: true,
            baseDir: plasmicDir,
        });
    }
}
exports.tryInitializePlasmicDir = tryInitializePlasmicDir;
async function readConfig(dir) {
    const configPath = upath_1.default.join(dir, "plasmic.json");
    const configData = await fs_1.promises.readFile(configPath);
    return JSON.parse(configData.toString());
}
exports.readConfig = readConfig;
async function saveConfig(dir, config) {
    const configPath = upath_1.default.join(dir, "plasmic.json");
    return fs_1.promises.writeFile(configPath, JSON.stringify(config, undefined, 2));
}
exports.saveConfig = saveConfig;
async function fixImports(dir) {
    const userCli = require(upath_1.default.join(dir, "node_modules", "@plasmicapp", "cli", "dist", "lib.js"));
    return userCli.fixImports({ yes: true, baseDir: dir });
}
exports.fixImports = fixImports;
function getPageUrl(path) {
    // Convert a page path (like pages/my-page.tsx or ../pages/index.jsx) into their
    // corresponding path (/my-page).
    let [_, url] = path.split(/pages(.*)\..*$/);
    // Remove the ending "/index" path, which is required for file routing but not for URLs.
    // Examples:
    // /index -> /
    // /index/index -> /index
    if (url.endsWith("index")) {
        url = url.slice(0, -6);
    }
    return url === "" ? "/" : url;
}
function getPagesFromConfig(plasmicDir, config) {
    const componentData = [];
    for (const project of config.projects) {
        for (const component of project.components) {
            if (component.componentType !== "page") {
                continue;
            }
            componentData.push({
                name: component.name,
                projectId: project.projectId,
                path: upath_1.default.join(plasmicDir, "components", component.importSpec.modulePath),
                url: getPageUrl(component.importSpec.modulePath),
            });
        }
    }
    return componentData;
}
exports.getPagesFromConfig = getPagesFromConfig;
async function syncProject(dir, userDir, projects) {
    metadata_1.setMetadata({
        source: "loader",
        scheme: "loader",
    });
    const userCli = require(upath_1.default.join(dir, "node_modules", "@plasmicapp", "cli", "dist", "lib.js"));
    return userCli.sync({
        yes: true,
        loaderConfig: upath_1.default.join(userDir, "plasmic-loader.json"),
        projects,
        baseDir: dir,
    });
}
exports.syncProject = syncProject;
