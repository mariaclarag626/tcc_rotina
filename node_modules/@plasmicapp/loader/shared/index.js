"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.maybeAddToGitIgnore = exports.onPostInit = exports.initLoader = exports.convertOptsToLoaderConfig = exports.ensurePlasmicIsNotStale = exports.watchForChanges = void 0;
const fs_1 = require("fs");
const rmfr_1 = __importDefault(require("rmfr"));
const upath_1 = __importDefault(require("upath"));
const cli = __importStar(require("./cli"));
const gen = __importStar(require("./gen"));
const logger = __importStar(require("./logger"));
const metadata_1 = require("./metadata");
const sentry_1 = require("./sentry");
const substitutions = __importStar(require("./substitutions"));
const utils_1 = require("./utils");
const validation_1 = require("./validation");
const ABOUT_PAGE_URL = "https://docs.plasmic.app/learn/loader-config";
async function watchForChanges(opts, onRegisterPages) {
    const { plasmicDir, pageDir } = opts;
    let currentConfig = await cli.readConfig(plasmicDir);
    // Initialize sentry again, as this may not have been
    // initialized in next.
    await sentry_1.initSentry(opts);
    metadata_1.setMetadata({
        source: "loader",
        scheme: "loader",
    });
    const userCli = require(upath_1.default.join(plasmicDir, "node_modules", "@plasmicapp", "cli", "dist", "lib.js"));
    utils_1.spawn(userCli.watchProjects({
        yes: true,
        projects: opts.projects.map(({ projectId }) => projectId),
        baseDir: plasmicDir,
    }, {}, async function () {
        await gen.generateAll({ dir: plasmicDir, pageDir });
        currentConfig = await cli.readConfig(plasmicDir);
        if (onRegisterPages) {
            await onRegisterPages(cli.getPagesFromConfig(plasmicDir, currentConfig), currentConfig).catch((e) => logger.crash(e.message, e));
        }
    }));
}
exports.watchForChanges = watchForChanges;
async function ensurePlasmicIsNotStale(plasmicDir, opts) {
    const savedConfigPath = upath_1.default.join(plasmicDir, ".plasmic-loader-config.json");
    const currentConfig = JSON.stringify({ ...opts, watch: false });
    const savedConfig = await fs_1.promises
        .readFile(savedConfigPath)
        .then((file) => file.toString())
        .catch((error) => {
        if (error.code === "ENOENT") {
            return undefined;
        }
        throw error;
    });
    if (savedConfig === currentConfig) {
        return;
    }
    if (savedConfig !== undefined) {
        logger.info("Detected a change in the previous config. Deleting .plasmic directory...");
    }
    // Settings changed, so delete .plasmic dir.
    await rmfr_1.default(plasmicDir).catch((error) => {
        if (error.code !== "ENOTEMPTY" && error.code !== "EBUSY") {
            throw error;
        }
        logger.warn(`Unable to clear ${opts.plasmicDir}. Error: ${error.message}\n` +
            "If you made changes to your plasmic configuration, please delete this directory.");
    });
    await fs_1.promises.mkdir(plasmicDir, { recursive: true });
    await fs_1.promises.writeFile(savedConfigPath, currentConfig);
}
exports.ensurePlasmicIsNotStale = ensurePlasmicIsNotStale;
function readLoaderConfig(configPath) {
    return fs_1.promises
        .readFile(configPath)
        .then((file) => JSON.parse(file.toString()))
        .catch((error) => {
        if (error.code === "ENOENT") {
            return {};
        }
        throw error;
    });
}
async function convertOptsToLoaderConfig(userOpts, defaultOpts) {
    var _a;
    await validation_1.PlasmicOptsSchema.validateAsync({ ...defaultOpts, ...userOpts }).catch((error) => logger.crash(error.message));
    const configPath = upath_1.default.join(userOpts.dir || defaultOpts.dir, "plasmic-loader.json");
    const currentConfig = await readLoaderConfig(configPath);
    const currentProjects = Object.fromEntries((currentConfig.projects || []).map((project) => [
        project.projectId,
        project,
    ]));
    // Assigning all the user-assigned props, except projects (since the signature is different)
    // We'll handle projects below.
    Object.assign(currentConfig, { ...userOpts, projects: [] });
    (_a = userOpts.projects) === null || _a === void 0 ? void 0 : _a.filter((projectId) => !currentProjects[projectId]).forEach((projectId) => (currentProjects[projectId] = { projectId }));
    currentConfig.projects = Object.values(currentProjects);
    delete currentConfig.aboutThisFile; // Will be defined below.
    // Save user configuration.
    await fs_1.promises.writeFile(configPath, 
    // Sorting trick to have "aboutThisFile" be the first key.
    JSON.stringify({
        aboutThisFile: ABOUT_PAGE_URL,
        ...currentConfig,
        $schema: "./node_modules/@plasmicapp/loader/plasmic-loader.schema.json",
    }, undefined, 2));
    // Now create a new configuration, including defaults.
    const config = {
        aboutThisFile: currentConfig.aboutThisFile,
        projects: currentConfig.projects,
        watch: currentConfig.watch || defaultOpts.watch,
        dir: userOpts.dir || currentConfig.dir || defaultOpts.dir,
        plasmicDir: userOpts.plasmicDir || currentConfig.plasmicDir || defaultOpts.plasmicDir,
        pageDir: userOpts.pageDir || currentConfig.pageDir || defaultOpts.pageDir,
        initArgs: {
            ...(defaultOpts.initArgs || {}),
            ...(currentConfig.initArgs || {}),
            ...(userOpts.initArgs || {}),
        },
        substitutions: userOpts.substitutions ||
            currentConfig.substitutions ||
            defaultOpts.substitutions,
    };
    // Check if the user opts are up to date
    await ensurePlasmicIsNotStale(config.plasmicDir, userOpts);
    return config;
}
exports.convertOptsToLoaderConfig = convertOptsToLoaderConfig;
async function checkNoTopLevelPlasmicJson(config) {
    try {
        await fs_1.promises.access(upath_1.default.join(config.dir, "plasmic.json"));
        logger.crash('Top-level "plasmic.json" detected. It looks like you may be using Plasmic Codegen. Both codegen and loader are two ways in which you can consume your Plasmic designs. To prevent confusion, you cannot use both approaches.' +
            "\n\nRead more: https://docs.plasmic.app/learn/loader-vs-codegen/.");
    }
    catch (error) {
        if (error.code === "ENOENT") {
            return;
        }
        throw error;
    }
}
async function initLoader(config) {
    await sentry_1.initSentry(config);
    const { dir, pageDir, plasmicDir, initArgs = {} } = config;
    await checkNoTopLevelPlasmicJson(config);
    logger.info("Checking that your loader version is up to date.");
    await cli.ensureRequiredLoaderVersion();
    const projectIds = config.projects.map(({ projectId }) => projectId);
    logger.info(`Syncing plasmic projects: ${projectIds.join(", ")}`);
    await cli.tryInitializePlasmicDir(plasmicDir, initArgs);
    await cli.syncProject(plasmicDir, dir, projectIds);
    if (config.substitutions) {
        logger.info("Registering substitutions...");
        const cliConfig = await cli.readConfig(plasmicDir);
        substitutions.registerSubstitutions(plasmicDir, cliConfig, config.substitutions);
        await cli.saveConfig(plasmicDir, cliConfig);
        await cli.fixImports(plasmicDir);
    }
    logger.info("Generating loader...");
    return Promise.all([
        gen.genStaticNodeModuleExports(plasmicDir),
        gen.generateAll({ dir: plasmicDir, pageDir }),
    ]);
}
exports.initLoader = initLoader;
async function onPostInit(config, watch, onRegisterPages) {
    if (onRegisterPages) {
        const userConfig = await cli.readConfig(config.plasmicDir);
        await onRegisterPages(cli.getPagesFromConfig(config.plasmicDir, userConfig), config).catch((e) => logger.crash(e.message, e));
    }
    if (watch) {
        await watchForChanges(config, onRegisterPages);
    }
}
exports.onPostInit = onPostInit;
async function maybeAddToGitIgnore(gitIgnorePath, name) {
    const file = await fs_1.promises
        .readFile(gitIgnorePath)
        .then((content) => content.toString())
        .catch(async (error) => {
        if (error.code === "ENOENT") {
            logger.warn(".gitignore not found. Plasmic loader creates multiple files that are not meant to be checked into your repository. To silence this warning, please add a .gitignore.");
            return;
        }
        // For other errors, capture them but do not crash the process.
        await sentry_1.captureException(error);
        logger.warn(`Found error while trying to read .gitignore:\n\n ${error.message}\n\nPlease add "${name}" to your .gitignore.`);
        return "";
    });
    if (!file || file.includes(name))
        return;
    await fs_1.promises.writeFile(gitIgnorePath, `${file}\n# Plasmic loader code\n${name}\n`);
    logger.info(`Added "${name}" to your .gitignore.`);
}
exports.maybeAddToGitIgnore = maybeAddToGitIgnore;
